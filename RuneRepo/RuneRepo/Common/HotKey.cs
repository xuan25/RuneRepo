using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Interop;

namespace Common
{
    public static class HotKey
    {
        /// <summary>
        /// Enum of Hotkey modifiers
        /// </summary>
        public enum Modifier
        {
            MOD_ALT = 0x1,
            MOD_CONTROL = 0x2,
            MOD_SHIFT = 0x4,
            MOD_WIN = 0x8
        }

        /// <summary>
        /// Defines a system-wide hot key.
        /// https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerhotkey
        /// </summary>
        /// <param name="hWnd">A handle to the window that will receive WM_HOTKEY messages generated by the hot key. If this parameter is NULL, WM_HOTKEY messages are posted to the message queue of the calling thread and must be processed in the message loop.</param>
        /// <param name="id">The identifier of the hot key. If the hWnd parameter is NULL, then the hot key is associated with the current thread rather than with a particular window. If a hot key already exists with the same hWnd and id parameters, see Remarks for the action taken.</param>
        /// <param name="fsModifiers">The keys that must be pressed in combination with the key specified by the uVirtKey parameter in order to generate the WM_HOTKEY message. The fsModifiers parameter can be a combination of the following values.</param>
        /// <param name="vk">The virtual-key code of the hot key. See Virtual Key Codes.</param>
        /// <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.</returns>
        [DllImport("user32.dll")]
        private static extern bool RegisterHotKey(IntPtr hWnd, int id, Modifier fsModifiers, uint vk);

        /// <summary>
        /// Frees a hot key previously registered by the calling thread.
        /// https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterhotkey
        /// </summary>
        /// <param name="hWnd">A handle to the window associated with the hot key to be freed. This parameter should be NULL if the hot key is not associated with a window.</param>
        /// <param name="id">The identifier of the hot key to be freed.</param>
        /// <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.</returns>
        [DllImport("user32.dll")]
        private static extern bool UnregisterHotKey(IntPtr hWnd, int id);

        /// <summary>
        /// The message identifier of WM_HOTKEY.
        /// </summary>
        private const int WM_HOTKEY = 0x312;

        /// <summary>
        /// The delegate to handle hot key.
        /// </summary>
        public delegate void HotKeyHanlder();

        /// <summary>
        /// The Dictionary of hot key identifiers and handlers.
        /// </summary>
        private static Dictionary<int, HotKeyHanlder> HandlerDic { get; set; }

        /// <summary>
        /// The Dictionary of hot key identifiers and window.
        /// </summary>
        private static Dictionary<int, IntPtr> HWndDic { get; set; }

        /// <summary>
        /// The Set of related windows.
        /// </summary>
        private static HashSet<Window> HandledWindows { get; set; }

        /// <summary>
        /// The count of hotkeys registed.
        /// </summary>
        public static int Count { get; private set; }

        /// <summary>
        /// Init the static class
        /// </summary>
        static HotKey()
        {
            Count = 0;
            HandlerDic = new Dictionary<int, HotKeyHanlder>();
            HWndDic = new Dictionary<int, IntPtr>();
            HandledWindows = new HashSet<Window>();
        }

        /// <summary>
        /// Register a system-wide hot key.
        /// </summary>
        /// <param name="window">The window that will handle the hot key.</param>
        /// <param name="fsModifiers">The keys that must be pressed in combination with the key specified by the key parameter in order to trigger the hot key.</param>
        /// <param name="key">The key of the hot key.</param>
        /// <param name="id">The identifier of the hot key.</param>
        /// <param name="handler">The handler to handle the hot key.</param>
        /// <returns>Return true if succeeds, otherwise return false.</returns>
        public static bool Register(Window window, Modifier fsModifiers, VirtualKey key, out int id, HotKeyHanlder handler)
        {
            IntPtr hwnd = new WindowInteropHelper(window).Handle;
            if (HandledWindows.Add(window))
                HwndSource.FromHwnd(hwnd).AddHook(WndProc);
            id = Count++;
            if (!RegisterHotKey(hwnd, id, fsModifiers, (byte)key))
                return false;
            HandlerDic[id] = handler;
            HWndDic[id] = hwnd;
            return true;
        }

        /// <summary>
        /// Unregister a system-wide hot key.
        /// </summary>
        /// <param name="hWnd">The window that handle the hot key.</param>
        /// <param name="id">The identifier of the hot key.</param>
        public static bool UnRegister(int id)
        {
            if (HWndDic.TryGetValue(id, out IntPtr hWnd))
            {
                UnregisterHotKey(hWnd, id);
                return true;
            }
            return false;
        }

        /// <summary>
        /// WndProc matches the HwndSourceHook delegate signature so it can be passed to AddHook() as a callback. This is the same as overriding a Windows.Form's WncProc method.
        /// </summary>
        /// <param name="hwnd">The window handle</param>
        /// <param name="msg">The message ID</param>
        /// <param name="wParam">The message's wParam value, historically used in the win32 api for handles and integers</param>
        /// <param name="lParam">The message's lParam value, historically used in the win32 api to pass pointers</param>
        /// <param name="handled">A value that indicates whether the message was handled</param>
        /// <returns></returns>
        private static IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)
        {
            if (msg == WM_HOTKEY)
            {
                int id = wParam.ToInt32();
                if (HandlerDic.TryGetValue(id, out HotKeyHanlder callback))
                {
                    callback();
                }
            }
            return IntPtr.Zero;
        }
    }
}
